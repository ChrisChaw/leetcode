class Solution:
    def totalNQueens(self, n: int) -> int:
        if n < 1:
            return []
        self.count = 0
        self.DFS(n, 0, 0, 0, 0)
        return self.count

    def DFS(self, n, row, cols, pie, na):
        # 递归终止条件
        if row >= n:
            self.count += 1
            return

        bits = (~(cols | pie | na)) & ((1 << n) - 1)  # 得到当前所有的空位

        while bits:
            p = bits & -bits  # 取到最低位的1, x & (x-1):清零最低位的1
            bits = bits & (bits - 1)  # 在p位置上放入皇后
            self.DFS(n, row + 1, cols | p, (pie | p) << 1, (na | p) >> 1)
            # 不需要revert cols pie na 的状态
"""
参数说明：n是n皇后问题 递归一共有n层。row表示当前我们在审查哪一层。row >= n说明递归终止了。
1. 终止条件row >= n 说明得到结果了 count + 1就行了   
2. 处理当前层 在当前层扩散出新一层 新一层里要设置好判重的数组 也就是这里判重的新的参数 
3. 如果需要的话 要revert当前的状态

col pie na表示之前的那些皇后已经占据了哪些na pie na的位置了
  col | pie | na就得到了所有被上面皇后占领的格子位置  ～取反表示那些没有占领的格子就被赋为1了  &((1 << n) - 1)  表示把它的高位 把它的n皇后的n之前的那些位全部赋0  因为 我们不需要用到前面那些位置   
假设是8皇后 col pie na都是0 或在一起还是0 取反后 变成1       bits就是对这8个2进制的1放在这里 对这8个1分别循环 看能够放在第一列 第二列 ... 第8列 哪个位置   
每次放过之后 bits & -bits 得到最低位的1的位置p(放置皇后的位置)  取出来之后 就把皇后置于1这个位置  因为只要是1的位置 说明没有被之前的皇后攻击到  所以只要是1 就是可以放的  再进行新的一层的下探下去：row + 1  , 列的话 就要或上p所在的位置，pie的话 就是p所在的位置再左移一位   因为它往下走一列的话 就是这个pie往斜下角多打一位  所以是左移一位  na的话 是 或上了p之后 右移一位   因为它是往右下角多打一位  
打完之后 就进行了更深一层的DFS循环   循环完后 由于p这个位置是放了一个皇后的 现在要把这个位置清0: bits & (bits - 1)说明这个时候相当于把这个位已经占了  就要把这个位相应地清空  表示在p这个位置上放入皇后  所以p这个位置相当于已经被占据了
也就是把它最低位清0了  最低位清0了之后 再下探到新的一层  同时 bits里还包含1的话 就可以继续循环和试探  
它没有改变当前层的cols  pie  na的值  虽然它这里或上了p  或者是pie也或上了p 然后左移了1位  因为这个东西是个int 所以参数是被拷贝了一份出来  所以cols pie na在当前函数里面不管怎么循环值不改变   cols pie na没有被改变  所以这里不需要再revert cols pie na的状态 
"""
